<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Make .NET configuration system flexible again - Egor Grishechko's Blog</title>
    <meta name="description" content="Set-up .NET Core settings configuration in the flexible and shared-ready way">
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
</head>
<body>
    <header>
        <nav>
            <a href="/" class="logo">Egor Grishechko</a>
            <a href="/">Home</a>
        </nav>
    </header>

    <main>
        <article class="post">
            <header class="post-header">
                <h1>Make .NET configuration system flexible again</h1>
                <div class="post-meta">
                    <time datetime="2017-07-23">July 23, 2017</time>
                    <div class="tags"><span class="tag">entify framework</span> <span class="tag">asp.net core</span> <span class="tag">dot.net core</span></div>
                </div>
            </header>

            <div class="post-content">
                <p>Hi everyone! Today I want to talk about brand-new .NET Core configuration system.</p>

<p>As all we know, new versions of <code>Microsoft's</code> frameworks were written in the modular model. (<code>ASP.NET</code> isn't one dll anymore, it's a set of packages which can be turned on by demand).</p>

<p>A few weeks ago, I decided to wrote a simple api-consumer with using of <code>ASP.NET Core</code>.</p>

<figure><a href="/assets/images/scraper-scheme.JPG"><img src="/assets/images/scraper-scheme.JPG" alt="App architecture"></a><figcaption>App architecture</figcaption></figure>

So, I wanted to implement a simple app from <code>REST-endpoint</code> and <code>background service</code> for scraping data from <code>vk.com api</code>.
I planned that in the some interval of time background service makes requests to api and fetches fresh data. So, I decided to make a layer architecture.
After this decision, some interesting cases related with brand-new .NET core <code>configuration</code> system were found. I solved them by creating wrapper around this system.  
<a href="https://github.com/egorikas/dot-net-core-shared-configuration">Show me the code</a>

<h3>Same setting for two or three projects</h3>
We all living in the world, where <code>microservices</code> is not a just another one hipster word, but also real tendency in the world of big systems' architecture. 
But I think that even in this world there is a place for settings which can be same for the multiple projects. And my web-scraper is about this situation. 

<h3>Entity Framework Core and Migrations</h3>
Nowadays, DI is the importan part of .NET stack. If you want to configure
DbContext and open <a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext">official documentation</a>, you will find some examples.

``<code>csharp 			
public class BloggingContext : DbContext
{
    public BloggingContext(DbContextOptions<BloggingContext> options)
        : base(options)
    { }

    public DbSet<Blog> Blogs { get; set; }
}
<pre><code>At first glance everything&#39;s fine. But you&#39;ll have troubles, when you try to add migration with </code>dotnet ef migrations add {NameOfMigraion}<code>. You will have </code>System.MissingMethodException: No parameterless constructor defined for this object<code> problem. It can be fixed by adding custom </code>IDbContextFactory<code>. 
Custom factory allows us to construct context in the way we want to. But there is a big problem with </code>connection string<code>. How can we pass it to the context if application and IoC container aren&#39;t working in the moment, when migration is being created?
Official example offers us to hardcode </code>connection string<code>, such an awful practice.
</code></pre>csharp 			
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;

namespace MyProject
{
    public class BloggingContextFactory : IDbContextFactory<BloggingContext>
    {
        public BloggingContext Create()
        {
            var optionsBuilder = new DbContextOptionsBuilder<BloggingContext>();
            optionsBuilder.UseSqlite("Data Source=blog.db");

            return new BloggingContext(optionsBuilder.Options);
        }
    }
}
<pre><code>I tried to find a existing solution. This &lt;a href=&quot;https://www.benday.com/2017/02/17/ef-core-migrations-without-hard-coding-a-connection-string-using-idbcontextfactory/ &quot;&gt;blog-post&lt;/a&gt; offers to write some custom methods for parsing settings file and getting connection string. As for me it breaks of </code>Single Responsibility Principle<code> and force us for creating coupled code.

<h3>My solution</h3>
For resolving these cases I created a standalone project which works with settings and encapsulate logic for working with them in one place.

I decided to organise work through putting config files to the folder somewhere in the system and passing this folder&#39;s path to the application through </code>environment variables<code>.

So, my solution contains a few simple parts.
The first one encapsulates working with </code>environment variables<code>.
</code></pre>csharp 			
public interface IEnvironmentProvider
{
    string EnvironmentName { get;}
    string SettingsPath { get; }
}

public class EnvironmentProvider : IEnvironmentProvider
{
    public string EnvironmentName => Environment.GetEnvironmentVariable(ConfigurationConstants.EnvironmentVariableName);
    public string SettingsPath => Environment.GetEnvironmentVariable(ConfigurationConstants.SettingsPathVariableName);
}

public class ConfigurationConstants
{
    public static string SettingsPathVariableName => "SHAREDSETTINGS_LOCATION";
    public static string EnvironmentVariableName => "ASPNETCORE_ENVIRONMENT";
    public static string SettingsFileName => "appsettings.json";
    public static string SettingsEnviromentFileName => "appsettings.{0}.json";
}
<pre><code>I am sure that hardcoding string can&#39;t be a good idea, so I like to put them to the special classes (recourses, files, etc). When I do this, I always know where these strings can be found. In this scenarion we also prevent creating hard-coded string with duplicate content.

The second part is the helper class which extracts and parses </code>IConfigurationRoot<code>.
</code></pre>csharp 			
using System;
using Configuration.EnvironmentProvider;
using Microsoft.Extensions.Configuration;

namespace Configuration
{
    public class SettingsProvider
    {
        public static IConfigurationRoot GetConfigurationRoot(IEnvironmentProvider environmentProvider)
        {
            var builder = new ConfigurationBuilder()
                .SetBasePath(environmentProvider.SettingsPath)
                .AddJsonFile(ConfigurationConstants.SettingsFileName)
                .AddJsonFile(string.Format(ConfigurationConstants.SettingsEnviromentFileName, environmentProvider.EnvironmentName), optional: true)
                .AddEnvironmentVariables();

            return builder.Build();
        }      
    }
}
<pre><code></code>IEnvironmentProvider<code> is being passed through constructor. So, we have some flexibility with changing it for different cases, but also have opportunity to write </code>unit-test<code> for </code>GetConfigurationRoot<code> fast.

After implementing this code </code>BloggingContextFactory<code> would be looking like in the snippet below.
</code></pre>csharp 			
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;

namespace MyProject
{
    public class BloggingContextFactory : IDbContextFactory<BloggingContext>
    {
        public BloggingContext Create()
        {
            var configurationRoot = SettingsProvider.GetConfigurationRoot(new EnvironmentProvider());

            var optionsBuilder = new DbContextOptionsBuilder<BloggingContext>();
            //In my project I put "mainDb" to ConfigurationConstants class
            optionsBuilder.UseSqlite(configurationRoot.GetConnectionString("mainDb"));

            return new BloggingContext(optionsBuilder.Options);
        }
    }
}
</code>``

No magic, no hard-code connection strings. Just flexibility and fun :).

You can find source code on <a href="https://github.com/egorikas/dot-net-core-shared-configuration">github</a>.

<h3>Conclusion</h3>

That's all. I'll be happy, If this article helps you.
            </div>
        </article>
    </main>

    <footer>
        <p>&copy; 2026 Egor Grishechko. All rights reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>