<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solving of 'The type appears in two structurally incompatible initializations within a single LINQ to Entities query' problem - Egor Grishechko's Blog</title>
    <meta name="description" content="Solving of 'The type appears in two structurally incompatible initializations within a single LINQ to Entities query' problem">
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
</head>
<body>
    <header>
        <nav>
            <a href="/" class="logo">Egor Grishechko</a>
            <a href="/">Home</a>
        </nav>
    </header>

    <main>
        <article class="post">
            <header class="post-header">
                <h1>Solving of 'The type appears in two structurally incompatible initializations within a single LINQ to Entities query' problem</h1>
                <div class="post-meta">
                    <time datetime="2017-06-24">June 24, 2017</time>
                    <div class="tags"><span class="tag">entify framework</span> <span class="tag">linq</span></div>
                </div>
            </header>

            <div class="post-content">
                <p>Hi everyone! Today I want to talk about solving the 'The type appears in two structurally incompatible initializations within a single LINQ to Entities query' problem.</p>

<p>A few weeks ago, I faced off a horrified problem, my <code>LINQ to Entities query</code> didn't work and threw an exception:</p>

<p>System.NotSupportedException: 'The type '***' appears in two structurally incompatible initializations within a single LINQ to Entities query. </p>
<p>A type can be initialized in two places in the same query, but only if the same properties are set in both places and those properties are set in the same order.'</p>

<p>It was tought for me to find the answer, so I decided share it with you.</p>

<h3>How did I get it?</h3>

Let's imagine that we have two tables in a database, which contain different domain entities. 
There is a possibility that we will have to getting some info from them for joininig (for my case, I was creating a report system).
I'm not allowed to write article about that real case, but I am trying to do this with examples. So, there are two classes <code>A</code> and <code>B</code>.

``<code>csharp 			
    public class A
    {
        public string Name { get; set;}
        public string Rating { get; set;}
    }
<pre><code>
</code></pre>csharp 			
    public class B
    {
        public string Name { get; set;}
        public bool? IsSelected { get; set;}
    }
<pre><code>
And we want to get an instance of class C, which is union of A and B.

</code></pre>csharp 			
    public class C
    {
        public string Name { get; set;}
        public string Rating { get; set;}
        public bool? IsSelected { get; set;}		
    }
<pre><code>
So, I decided not to use a raw </code>SQL-request<code>. Instead of it, I used a </code>LINQ to Entities query<code>.

</code></pre>csharp 
    public List<C> UnionThem(){
		var firstPart = _context.A.Select(x => {
			Name = x.Name,
			IsSelected = null,
			Rating = x.Rating
		});

		var secondPart = _context.B.Select(x => {
			Rating = null,
			IsSelected = x.IsSelected,
			Name = x.Name
		});	

		return firstPart.Union(secondPart).ToList();	
	}			
<pre><code>
If you try to run this code, it will thrown &#39;The type appears in two structurally incompatible initializations within a single LINQ to Entities query&#39; exception.

<h3>Solvation</h3>

So, in my case solvation was simple. Variables in </code>Select<code> statement were in a wrong order. When I put them in the same order for both </code>Select<code>, this query started to work.

</code></pre>csharp 
    public List<C> UnionThem(){
		var firstPart = _context.A.Select(x => {
			Name = x.Name,
			Rating = x.Rating,
			IsSelected = null
		});

		var secondPart = _context.B.Select(x => {
			Name = x.Name,
			Rating = x.Rating,
			IsSelected = null
		});	

		return firstPart.Union(secondPart).ToList();	
	}			
</code>`<code>

<h3>Thoughts</h3>

I didn't find 100% correct answer why this happens. So, text below is just a result of my thoughts and seeing code of </code>Entity Framework<code>.

When </code>EF` builds a request to database, it parses the linq query to the raw SQL query. So, in the right case, the linq query above translates to 

<pre><code class="language-sql">SELECT
  Name,
  Rating,
  IsSelected
FROM (
  (
    SELECT
      Name,
      Rating,
      IsSelected
    FROM TableA
  )
  UNION ALL
  (
    SELECT
      Name,
      Rating,
      IsSelected
    FROM TableB
  )
)
</code></pre>
<p>When you have disordered statements EF gets crazy and can't translate them to the SQL. So, I think that the reason of problems is disordered arguments.</p>

<p>You can find EF source code on <a href="https://github.com/aspnet/EntityFramework6">github</a>.</p>

<h3>Conclusion</h3>

That's all. I'll be happy, If this article helps you.
            </div>
        </article>
    </main>

    <footer>
        <p>&copy; 2026 Egor Grishechko. All rights reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>